diff --git a/fs/eventpoll.c b/fs/eventpoll.c
index 06f4c5ae1..25bea396c 100644
--- a/fs/eventpoll.c
+++ b/fs/eventpoll.c
@@ -234,6 +234,12 @@ struct ep_pqueue {
 	struct epitem *epi;
 };
 
+/* Memorizing epoll_memo */
+struct ep_memo {
+	unsigned int 		epfd;
+	struct epoll_event	ev;
+};
+
 /*
  * Configuration options available inside /proc/sys/fs/epoll/
  */
@@ -2023,6 +2029,116 @@ static inline int epoll_mutex_lock(struct mutex *mutex, int depth,
 	return -EAGAIN;
 }
 
+int do_epoll_memo(int tfd, struct file *tfp, int nonblock) {
+	int error;
+	int full_check = 0;
+	struct fd f;
+	struct eventpoll *ep;
+	struct epitem *epi;
+	// struct eventpoll *tep = NULL;
+	struct ep_memo * epm;
+	struct epoll_event epds;
+
+	epm = tfp->f_ep_memo;
+	epds = epm->ev;
+
+	error = -EBADF;
+	f = fdget(epm->epfd);
+	if (!f.file)
+		goto error_return;
+
+	/* Verify struct file exists */
+	// if (!tfp)
+	// 	goto error_fput;
+
+	/* The target file descriptor must support poll */
+	error = -EPERM;
+	if (!file_can_poll(tfp))
+		goto error_fput;
+
+	/* Check if EPOLLWAKEUP is allowed */
+	ep_take_care_of_epollwakeup(&epds);
+
+	error = -EINVAL;
+	if (!is_file_epoll(f.file))
+		goto error_fput;
+
+	// not relevent at this moment
+	/*
+	 * epoll adds to the wakeup queue at EPOLL_CTL_ADD time only,
+	 * so EPOLLEXCLUSIVE is not allowed for a EPOLL_CTL_MOD operation.
+	 * Also, we do not currently supported nested exclusive wakeups.
+	 */
+	// if (ep_op_has_event(op) && (epds->events & EPOLLEXCLUSIVE)) {
+	// 	if (op == EPOLL_CTL_MOD)
+	// 		goto error_tgt_fput;
+	// 	if (op == EPOLL_CTL_ADD && (is_file_epoll(tf.file) ||
+	// 			(epds->events & ~EPOLLEXCLUSIVE_OK_BITS)))
+	// 		goto error_tgt_fput;
+	// }
+
+	/*
+	 * At this point it is safe to assume that the "private_data" contains
+	 * our own data structure.
+	 */
+	ep = f.file->private_data;
+
+	error = epoll_mutex_lock(&ep->mtx, 0, nonblock);
+	if (error)
+		goto error_fput;
+
+	/*
+	 * Try to lookup the file inside our RB tree. Since we grabbed "mtx"
+	 * above, we can be sure to be able to use the item looked up by
+	 * ep_find() till we release the mutex.
+	 */
+	epi = ep_find(ep, tfp, tfd);
+
+	error = -EINVAL;
+	if (!epi) {
+		epds.events |= EPOLLERR | EPOLLHUP;
+		error = ep_insert(ep, &epds, tfp, tfd, full_check);
+	} else if (!(epi->event.events & ~EP_PRIVATE_BITS)) {	
+		if (!(epi->event.events & EPOLLEXCLUSIVE)) {
+			epds.events |= EPOLLERR | EPOLLHUP;
+			error = ep_modify(ep, epi, &epds);
+		}
+	} else {
+		error = 0;
+	}
+
+	mutex_unlock(&ep->mtx);
+
+error_fput:
+	fdput(f);
+error_return:
+	return error;
+}
+
+static int do_epoll_memo_init(int epfd, int fd, struct epoll_event * event, int nonblock) 
+{
+	int error;
+	struct fd f;
+
+	error = 0;
+	f = fdget(fd);
+	if (!f.file) {
+		error = -EBADF;
+		goto error_return;
+	}
+
+	if (!(f.file->f_ep_memo)) {
+		f.file->f_ep_memo = kmalloc(sizeof(struct ep_memo), GFP_KERNEL); // malloc the field
+	}
+
+	f.file->f_ep_memo->epfd = epfd;
+	f.file->f_ep_memo->ev = *event;
+
+	fdput(f);
+error_return:
+	return error;
+}
+
 int do_epoll_ctl(int epfd, int op, int fd, struct epoll_event *epds,
 		 bool nonblock)
 {
@@ -2176,13 +2292,21 @@ int do_epoll_ctl(int epfd, int op, int fd, struct epoll_event *epds,
 SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,
 		struct epoll_event __user *, event)
 {
+	int err;
 	struct epoll_event epds;
 
 	if (ep_op_has_event(op) &&
 	    copy_from_user(&epds, event, sizeof(struct epoll_event)))
 		return -EFAULT;
 
-	return do_epoll_ctl(epfd, op, fd, &epds, false);
+	if (op & ~EPOLL_CTL_MEMO) {
+		err = do_epoll_ctl(epfd, op & ~EPOLL_CTL_MEMO, fd, &epds, false);
+	}
+	if (op & EPOLL_CTL_MEMO) {
+		err = do_epoll_memo_init(epfd, fd, &epds, false);
+	}
+
+	return err;
 }
 
 /*
diff --git a/fs/file_table.c b/fs/file_table.c
index 45437f8e1..7c0dfb965 100644
--- a/fs/file_table.c
+++ b/fs/file_table.c
@@ -116,6 +116,7 @@ static struct file *__alloc_file(int flags, const struct cred *cred)
 	f->f_flags = flags;
 	f->f_mode = OPEN_FMODE(flags);
 	/* f->f_version: 0 */
+	f->f_ep_memo = NULL;
 
 	return f;
 }
@@ -264,6 +265,9 @@ static void __fput(struct file *file)
 	might_sleep();
 
 	fsnotify_close(file);
+	if (file->f_ep_memo) {
+		kfree(file->f_ep_memo);
+	}
 	/*
 	 * The function eventpoll_release() should be the first called
 	 * in the file cleanup chain.
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 56eba7234..e4ffbe0ce 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -71,6 +71,7 @@ struct fsverity_operations;
 struct fs_context;
 struct fs_parameter_spec;
 struct fileattr;
+struct ep_memo;
 
 extern void __init inode_init(void);
 extern void __init inode_init_early(void);
@@ -996,6 +997,9 @@ struct file {
 #ifdef CONFIG_EPOLL
 	/* Used by fs/eventpoll.c to link all the hooks to this file */
 	struct hlist_head	*f_ep;
+
+	struct ep_memo		*f_ep_memo;
+
 #endif /* #ifdef CONFIG_EPOLL */
 	struct address_space	*f_mapping;
 	errseq_t		f_wb_err;
diff --git a/include/uapi/linux/eventpoll.h b/include/uapi/linux/eventpoll.h
index 8a3432d0f..e96ce24b7 100644
--- a/include/uapi/linux/eventpoll.h
+++ b/include/uapi/linux/eventpoll.h
@@ -26,6 +26,7 @@
 #define EPOLL_CTL_ADD 1
 #define EPOLL_CTL_DEL 2
 #define EPOLL_CTL_MOD 3
+#define EPOLL_CTL_MEMO 2048
 
 /* Epoll event masks */
 #define EPOLLIN		(__force __poll_t)0x00000001
diff --git a/net/socket.c b/net/socket.c
index 7f64a6ecc..4fad9acb4 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -106,6 +106,8 @@
 #include <linux/errqueue.h>
 #include <linux/ptp_clock_kernel.h>
 
+int do_epoll_memo(int tfd, struct file *tfp, int nonblock);
+
 #ifdef CONFIG_NET_RX_BUSY_POLL
 unsigned int sysctl_net_busy_read __read_mostly;
 unsigned int sysctl_net_busy_poll __read_mostly;
@@ -1846,6 +1848,11 @@ int __sys_accept4(int fd, struct sockaddr __user *upeer_sockaddr,
 		ret = __sys_accept4_file(f.file, 0, upeer_sockaddr,
 						upeer_addrlen, flags,
 						rlimit(RLIMIT_NOFILE));
+
+		if (f.file->f_ep_memo && (ret == -EAGAIN || ret == -EWOULDBLOCK)) {
+			ret = do_epoll_memo(fd, f.file, false) ? : ret;
+		}
+
 		fdput(f);
 	}
 
@@ -2092,6 +2099,10 @@ int __sys_recvfrom(int fd, void __user *ubuf, size_t size, unsigned int flags,
 		flags |= MSG_DONTWAIT;
 	err = sock_recvmsg(sock, &msg, flags);
 
+	if (sock->file->f_ep_memo && (err == -EAGAIN || err == -EWOULDBLOCK)) {
+		err = do_epoll_memo(fd, sock->file, false) ? : err;
+	}
+
 	if (err >= 0 && addr != NULL) {
 		err2 = move_addr_to_user(&address,
 					 msg.msg_namelen, addr, addr_len);
@@ -2699,6 +2710,11 @@ long __sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned int flags,
 
 	err = ___sys_recvmsg(sock, msg, &msg_sys, flags, 0);
 
+	if (sock->file->f_ep_memo && (err == -EAGAIN || err == -EWOULDBLOCK)) {
+		err = do_epoll_memo(fd, sock->file, false) ? : err;
+	}
+
+
 	fput_light(sock->file, fput_needed);
 out:
 	return err;
