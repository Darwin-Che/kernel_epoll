diff --git a/arch/x86/entry/syscalls/syscall_64.tbl b/arch/x86/entry/syscalls/syscall_64.tbl
index 18b5500ea..d7d9e53a3 100644
--- a/arch/x86/entry/syscalls/syscall_64.tbl
+++ b/arch/x86/entry/syscalls/syscall_64.tbl
@@ -413,5 +413,6 @@
 545	x32	execveat		compat_sys_execveat
 546	x32	preadv2			compat_sys_preadv64v2
 547	x32	pwritev2		compat_sys_pwritev64v2
+548	64	read_epoll_ctl		sys_read_epoll_ctl
 # This is the end of the legacy x32 range.  Numbers 548 and above are
 # not special and are not to be used for x32-specific syscalls.
diff --git a/fs/eventpoll.c b/fs/eventpoll.c
index 06f4c5ae1..7b20a2318 100644
--- a/fs/eventpoll.c
+++ b/fs/eventpoll.c
@@ -2294,6 +2294,32 @@ SYSCALL_DEFINE6(epoll_pwait2, int, epfd, struct epoll_event __user *, events,
 			      sigmask, sigsetsize);
 }
 
+long fcntl_handle(unsigned int fd, unsigned int cmd, unsigned long arg);
+
+SYSCALL_DEFINE6(read_epoll_ctl, int, fd, void *, buf, size_t, count,
+		int, epfd, int, op, struct epoll_event *, event)
+{
+	long fcntl_result;
+	ssize_t read_result;
+	// check if fd is nonblocking
+	fcntl_result = fcntl_handle(fd, F_GETFL, 0) & O_NONBLOCK;
+	if (fcntl_result == 0) {
+		return -EINVAL;
+	}
+
+	// invoke sys_read on selected input params
+	read_result = ksys_read(fd, buf, count);
+	
+	// check sys_read return value and errno to check if it blocks
+	if (read_result != -EAGAIN) {
+		if (read_result < 0) printk("read_epoll_ctl sys_read returns unhandled error!\n");
+		return read_result;
+	}
+	
+	// if sys_read blocks, pass selected input params to do_epoll_ctl
+	return do_epoll_ctl(epfd, op, fd, event, false);
+}
+
 #ifdef CONFIG_COMPAT
 static int do_compat_epoll_pwait(int epfd, struct epoll_event __user *events,
 				 int maxevents, struct timespec64 *timeout,
diff --git a/fs/fcntl.c b/fs/fcntl.c
index 9c6c6a3e2..55560584e 100644
--- a/fs/fcntl.c
+++ b/fs/fcntl.c
@@ -454,6 +454,30 @@ static int check_fcntl_cmd(unsigned cmd)
 	return 0;
 }
 
+long fcntl_handle(unsigned int fd, unsigned int cmd, unsigned long arg)
+{
+	struct fd f = fdget_raw(fd);
+	long err = -EBADF;
+
+	if (!f.file)
+		goto out;
+
+	if (unlikely(f.file->f_mode & FMODE_PATH)) {
+		if (!check_fcntl_cmd(cmd))
+			goto out1;
+	}
+
+	err = security_file_fcntl(f.file, cmd, arg);
+	if (!err)
+		err = do_fcntl(fd, cmd, arg, f.file);
+
+out1:
+ 	fdput(f);
+out:
+	return err;
+}
+
+
 SYSCALL_DEFINE3(fcntl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)
 {	
 	struct fd f = fdget_raw(fd);
