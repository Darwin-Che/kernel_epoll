diff --git a/arch/x86/entry/syscalls/syscall_64.tbl b/arch/x86/entry/syscalls/syscall_64.tbl
index 18b5500ea..7bc3bca62 100644
--- a/arch/x86/entry/syscalls/syscall_64.tbl
+++ b/arch/x86/entry/syscalls/syscall_64.tbl
@@ -415,3 +415,4 @@
 547	x32	pwritev2		compat_sys_pwritev64v2
 # This is the end of the legacy x32 range.  Numbers 548 and above are
 # not special and are not to be used for x32-specific syscalls.
+548	64	recv_epoll_add		sys_recv_epoll_add
\ No newline at end of file
diff --git a/fs/eventpoll.c b/fs/eventpoll.c
index 06f4c5ae1..cf7db4ca1 100644
--- a/fs/eventpoll.c
+++ b/fs/eventpoll.c
@@ -2023,6 +2023,83 @@ static inline int epoll_mutex_lock(struct mutex *mutex, int depth,
 	return -EAGAIN;
 }
 
+int do_epoll_add_from_file(int epfd, int fd, struct file *tff, struct epoll_event *epds, bool nonblock) 
+{
+	int error;
+	int full_check = 0;
+	struct fd f;
+	struct eventpoll *ep;
+	struct epitem *epi;
+	struct eventpoll *tep = NULL;
+
+	error = -EBADF;
+	f = fdget(epfd);
+	if (!f.file)
+		goto error_return;
+
+	/* Verify struct file exists */
+	// if (!tff)
+	// 	goto error_fput;
+
+	/* The target file descriptor must support poll */
+	error = -EPERM;
+	if (!file_can_poll(tff))
+		goto error_fput;
+
+	/* Check if EPOLLWAKEUP is allowed */
+	ep_take_care_of_epollwakeup(epds);
+
+	error = -EINVAL;
+	if (!is_file_epoll(f.file))
+		goto error_fput;
+
+	// not relevent at this moment
+	/*
+	 * epoll adds to the wakeup queue at EPOLL_CTL_ADD time only,
+	 * so EPOLLEXCLUSIVE is not allowed for a EPOLL_CTL_MOD operation.
+	 * Also, we do not currently supported nested exclusive wakeups.
+	 */
+	// if (ep_op_has_event(op) && (epds->events & EPOLLEXCLUSIVE)) {
+	// 	if (op == EPOLL_CTL_MOD)
+	// 		goto error_tgt_fput;
+	// 	if (op == EPOLL_CTL_ADD && (is_file_epoll(tf.file) ||
+	// 			(epds->events & ~EPOLLEXCLUSIVE_OK_BITS)))
+	// 		goto error_tgt_fput;
+	// }
+
+	/*
+	 * At this point it is safe to assume that the "private_data" contains
+	 * our own data structure.
+	 */
+	ep = f.file->private_data;
+
+	error = epoll_mutex_lock(&ep->mtx, 0, nonblock);
+	if (error)
+		goto error_fput;
+
+	/*
+	 * Try to lookup the file inside our RB tree. Since we grabbed "mtx"
+	 * above, we can be sure to be able to use the item looked up by
+	 * ep_find() till we release the mutex.
+	 */
+	epi = ep_find(ep, tff, fd);
+
+	error = -EINVAL;
+	// epoll_ctl add
+	if (!epi) {
+		epds->events |= EPOLLERR | EPOLLHUP;
+		error = ep_insert(ep, epds, tff, fd, full_check);
+	} else
+		error = -EEXIST;
+
+	mutex_unlock(&ep->mtx);
+
+error_fput:
+	fdput(f);
+error_return:
+	return error;
+}
+
 int do_epoll_ctl(int epfd, int op, int fd, struct epoll_event *epds,
 		 bool nonblock)
 {
diff --git a/net/socket.c b/net/socket.c
index 7f64a6ecc..d39bd1c6e 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -2121,6 +2121,64 @@ SYSCALL_DEFINE4(recv, int, fd, void __user *, ubuf, size_t, size,
 	return __sys_recvfrom(fd, ubuf, size, flags, NULL, NULL);
 }
 
+int do_epoll_add_from_file(int epfd, int fd, struct file *tff, struct epoll_event *epds, bool nonblock);
+
+SYSCALL_DEFINE6(recv_epoll_add, int, fd, void __user *, ubuf, size_t, size,
+		unsigned int, flags, 
+		int, epfd, struct epoll_event *, event) 
+{
+	struct sockaddr __user *addr = NULL;
+	int __user *addr_len = NULL;
+	struct socket *sock;
+	struct iovec iov;
+	struct msghdr msg;
+	struct sockaddr_storage address;
+	int err, err2;
+	int fput_needed;
+
+	err = import_single_range(READ, ubuf, size, &iov, &msg.msg_iter);
+	if (unlikely(err))
+		return err;
+	sock = sockfd_lookup_light(fd, &err, &fput_needed);
+	if (!sock)
+		goto out;
+
+	if (sock->file->f_flags & O_NONBLOCK) {
+		flags |= MSG_DONTWAIT;
+	} else {
+		err = -EINVAL;
+		goto error_fput;
+	}
+
+	msg.msg_control = NULL;
+	msg.msg_controllen = 0;
+	/* Save some cycles and don't copy the address if not needed */
+	msg.msg_name = addr ? (struct sockaddr *)&address : NULL;
+	/* We assume all kernel code knows the size of sockaddr_storage */
+	msg.msg_namelen = 0;
+	msg.msg_iocb = NULL;
+	msg.msg_flags = 0;
+
+	err = sock_recvmsg(sock, &msg, flags);
+
+	if (err == -EAGAIN || err == -EWOULDBLOCK) {
+		err = do_epoll_add_from_file(epfd, fd, sock->file, event, false);
+		goto error_fput;
+	}
+
+	if (err >= 0 && addr != NULL) {
+		err2 = move_addr_to_user(&address,
+					 msg.msg_namelen, addr, addr_len);
+		if (err2 < 0)
+			err = err2;
+	}
+
+error_fput:
+	fput_light(sock->file, fput_needed);
+out:
+	return err;
+}
+
 static bool sock_use_custom_sol_socket(const struct socket *sock)
 {
 	const struct sock *sk = sock->sk;
